'''
DFS, depth-first search.
Бежим до упора. возвращаемся на шаг назад и по другой ветке бежим до упора.
Когда пути из данной вершины закончились отступаем еще на шаг назад.
Реализуется через стек (LIFO).
Часто используется стек рекурсивно вызываемых функций.
Но не в этом коде.
'''


def dfs(graph, start):
    '''
    обходит граф в глубину (DFS) без использования рекурсии.
    Использует стек для хранения вершин, которые еще надо обойти,
    пока полностью не опустошит его.
    '''

    # создаем:
    # множество для хранения уже обработанных вершин
    # (множество, это чтобы был быстрый доступ?);
    # список впервые посещенных вершин, который мы и возвратим;
    # стек (LIFO) вершин, которые мы собираемся обойти
    is_visited = set()
    passed = []
    stack = [start]

    # откусываем правую вершинку из стека, записываем ее
    # в is_visited и passed, добавляем ее соседей в стек
    # (в этой программе соседи добавляются так, чтобы обегать их с самых левых;
    # вовсе не обязательная вещь, как я понимаю)
    while stack:
        vertex = stack.pop()
        if vertex not in is_visited:
            is_visited.add(vertex)
            passed.append(vertex)
            stack.extend(reversed(graph[vertex]))

    return passed


g = {
    0: [1, 8],
    1: [0],
    2: [3, 4, 5, 8],
    3: [2],
    4: [2, 7],
    5: [2, 6],
    6: [5, 8],
    7: [4, 6],
    8: [0, 2, 6]
}


v = int(input('Введите название вершины: '))
print(dfs(g, v))

'''[0, 1, 8, 2, 3, 4, 7, 6, 5]'''